#!/usr/bin/env node

/**
 * Wrapper to run TypeScript dead code detector
 * This works around ESM module issues
 */

const { execSync } = require('child_process');
const path = require('path');

console.log('üîç Starting AIDA Dead Code Detection...\n');

try {
  // Change to project root
  process.chdir(path.join(__dirname, '../../..'));
  
  // Run ts-prune first
  console.log('üîé Running ts-prune for unused exports...');
  try {
    const tsPruneOutput = execSync('npx ts-prune --project tsconfig.json', {
      encoding: 'utf8',
      stdio: 'pipe'
    });
    
    // Save ts-prune output
    const fs = require('fs');
    fs.writeFileSync('Docs/scripts/dead-code/report/ts-prune-output.txt', tsPruneOutput);
    
    const unusedCount = (tsPruneOutput.match(/\n/g) || []).length;
    console.log(`   Found ${unusedCount} potentially unused exports\n`);
  } catch (e) {
    console.log('   ‚ö†Ô∏è  ts-prune analysis failed\n');
  }

  // Run simple dead code analysis
  const fs = require('fs');
  const crypto = require('crypto');
  
  console.log('üìä Analyzing project structure...');
  
  // Count files
  let totalFiles = 0;
  let emptyFiles = [];
  let duplicates = new Map();
  let commentedBlocks = [];
  
  function scanDirectory(dir) {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !item.includes('node_modules') && !item.includes('.git')) {
        scanDirectory(fullPath);
      } else if (stat.isFile() && item.endsWith('.ts') && !item.endsWith('.d.ts')) {
        totalFiles++;
        
        // Read file content
        const content = fs.readFileSync(fullPath, 'utf8');
        
        // Check for empty files
        if (content.trim().length < 10) {
          emptyFiles.push(fullPath);
        }
        
        // Calculate hash for duplicates
        const hash = crypto.createHash('md5').update(content).digest('hex');
        if (!duplicates.has(hash)) {
          duplicates.set(hash, []);
        }
        duplicates.get(hash).push(fullPath);
        
        // Find large comment blocks
        const multiLineComments = content.match(/\/\*[\s\S]*?\*\//g) || [];
        const consecutiveComments = content.match(/(\/\/.*\n){4,}/g) || [];
        
        for (const comment of [...multiLineComments, ...consecutiveComments]) {
          if (comment.length > 100 && /\b(function|class|const|let|if|for|while|return)\b/.test(comment)) {
            commentedBlocks.push({
              file: fullPath,
              preview: comment.substring(0, 100) + '...'
            });
          }
        }
      }
    }
  }
  
  scanDirectory('src');
  
  console.log(`   Total TypeScript files: ${totalFiles}`);
  console.log(`   Empty files: ${emptyFiles.length}`);
  
  // Find duplicate files
  let duplicateCount = 0;
  duplicates.forEach((files, hash) => {
    if (files.length > 1) {
      duplicateCount += files.length - 1;
    }
  });
  console.log(`   Duplicate files: ${duplicateCount}`);
  console.log(`   Commented code blocks: ${commentedBlocks.length}\n`);
  
  // Generate report
  console.log('üìù Generating report...');
  
  const reportDate = new Date().toISOString().split('T')[0];
  const reportPath = `Docs/scripts/dead-code/report/dead-code-analysis-${reportDate}.md`;
  
  let report = `# üîç AIDA Dead Code Analysis Report

**Generated**: ${new Date().toLocaleString()}  
**Total Files Analyzed**: ${totalFiles}

## üìä Summary

- **Empty Files**: ${emptyFiles.length}
- **Duplicate Files**: ${duplicateCount}
- **Commented Code Blocks**: ${commentedBlocks.length}
- **Unused Exports**: See ts-prune-output.txt

## üìÑ Empty Files (${emptyFiles.length})

${emptyFiles.length > 0 ? emptyFiles.map(f => `- \`${f}\``).join('\n') : '‚úÖ No empty files found.'}

## üë• Duplicate Files

`;

  duplicates.forEach((files, hash) => {
    if (files.length > 1) {
      report += `\n### Hash: ${hash.substring(0, 8)}\n`;
      files.forEach(f => {
        report += `- \`${f}\`\n`;
      });
    }
  });

  report += `\n## üí¨ Commented Code Blocks (${commentedBlocks.length})

${commentedBlocks.slice(0, 20).map(block => 
`### ${block.file}
\`\`\`
${block.preview}
\`\`\`
`).join('\n')}

${commentedBlocks.length > 20 ? `\n... and ${commentedBlocks.length - 20} more blocks` : ''}

## üéØ Recommendations

1. Review and remove empty files
2. Consolidate duplicate files
3. Remove commented code blocks
4. Review unused exports in ts-prune-output.txt

---
Generated by AIDA Dead Code Detector`;

  fs.mkdirSync(path.dirname(reportPath), { recursive: true });
  fs.writeFileSync(reportPath, report);
  
  console.log(`\n‚úÖ Report generated: ${reportPath}`);
  console.log('\nüìä Quick Stats:');
  console.log(`   Health Score: ${Math.round((1 - (emptyFiles.length + duplicateCount) / totalFiles) * 100)}%`);
  
} catch (error) {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
}