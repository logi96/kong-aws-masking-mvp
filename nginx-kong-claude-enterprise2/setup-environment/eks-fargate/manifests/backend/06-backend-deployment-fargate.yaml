# Backend API Deployment for EKS Fargate
# Node.js backend service with Fargate security contexts

apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-api-fargate
  namespace: kong-aws-masking
  labels:
    app.kubernetes.io/name: backend-api
    app.kubernetes.io/part-of: kong-aws-masking-enterprise
    app.kubernetes.io/version: "2.0.0"
    app.kubernetes.io/component: backend-service
    platform: eks-fargate
    compute-type: fargate
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: backend-api
      platform: eks-fargate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: backend-api
        app.kubernetes.io/part-of: kong-aws-masking-enterprise
        app.kubernetes.io/version: "2.0.0"
        app.kubernetes.io/component: backend-service
        platform: eks-fargate
        compute-type: fargate
      annotations:
        # Fargate-specific annotations
        eks.amazonaws.com/fargate-profile: kong-aws-masking-profile
        # Security annotations
        container.apparmor.security.beta.kubernetes.io/backend-api: runtime/default
        # Prometheus scraping
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: kong-aws-masking-fargate
      
      # Fargate-required security context
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534  # nobody user
        runAsGroup: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      
      # DNS configuration
      dnsPolicy: ClusterFirst
      dnsConfig:
        options:
        - name: ndots
          value: "2"
        - name: edns0
      
      # Init container for dependencies check
      initContainers:
      - name: wait-for-kong
        image: curlimages/curl:8.4.0
        imagePullPolicy: IfNotPresent
        securityContext:
          runAsNonRoot: true
          runAsUser: 65534
          runAsGroup: 65534
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        command: ['sh', '-c']
        args:
        - |
          echo "Waiting for Kong Gateway to be ready..."
          until curl -f http://kong-gateway-service.kong-aws-masking.svc.cluster.local:8100/status; do
            echo "Kong Gateway not ready, waiting..."
            sleep 5
          done
          echo "Kong Gateway is ready!"
        resources:
          requests:
            cpu: "50m"
            memory: "64Mi"
          limits:
            cpu: "100m"
            memory: "128Mi"
        volumeMounts:
        - name: tmp-init
          mountPath: /tmp
      
      # Main containers
      containers:
      # Backend API container
      - name: backend-api
        image: node:20-alpine
        imagePullPolicy: IfNotPresent
        
        # Fargate-required container security context
        securityContext:
          runAsNonRoot: true
          runAsUser: 65534
          runAsGroup: 65534
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
        
        # Fargate-compliant resource requirements (0.5 vCPU, 1GB)
        resources:
          requests:
            cpu: "500m"
            memory: "1Gi"
          limits:
            cpu: "1"
            memory: "2Gi"
        
        # Working directory and command
        workingDir: /app
        command: ["node", "server.js"]
        
        # Environment variables
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "3000"
        - name: TZ
          value: "Asia/Seoul"
        
        # Kong Gateway configuration
        - name: KONG_ADMIN_URL
          value: "http://kong-admin-service.kong-aws-masking.svc.cluster.local:8001"
        - name: KONG_PROXY_URL
          value: "http://kong-gateway-service.kong-aws-masking.svc.cluster.local:8000"
        
        # ElastiCache configuration
        - name: ELASTICACHE_ENDPOINT
          valueFrom:
            configMapKeyRef:
              name: elasticache-config
              key: ELASTICACHE_ENDPOINT
        - name: ELASTICACHE_PORT
          valueFrom:
            configMapKeyRef:
              name: elasticache-config
              key: ELASTICACHE_PORT
        - name: REDIS_HOST
          valueFrom:
            configMapKeyRef:
              name: elasticache-config
              key: ELASTICACHE_ENDPOINT
        - name: REDIS_PORT
          valueFrom:
            configMapKeyRef:
              name: elasticache-config
              key: ELASTICACHE_PORT
        
        # Claude API configuration
        - name: ANTHROPIC_API_KEY
          valueFrom:
            secretKeyRef:
              name: kong-plugin-config
              key: anthropic-api-key
        - name: ANTHROPIC_BASE_URL
          value: "http://nginx-internal-service.kong-aws-masking.svc.cluster.local:8082/v1"
        
        # Application configuration
        - name: AWS_REGION
          value: "ap-northeast-2"
        - name: LOG_LEVEL
          value: "info"
        - name: ENABLE_METRICS
          value: "true"
        - name: HEALTH_CHECK_INTERVAL
          value: "30000"
        
        # Ports
        ports:
        - name: http
          containerPort: 3000
          protocol: TCP
        
        # Volume mounts for writable directories
        volumeMounts:
        - name: backend-source
          mountPath: /app
          readOnly: true
        - name: backend-tmp
          mountPath: /tmp
        - name: backend-logs
          mountPath: /app/logs
        - name: node-cache
          mountPath: /home/node/.npm
        - name: app-cache
          mountPath: /app/node_modules/.cache
        
        # Health checks
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
            scheme: HTTP
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          successThreshold: 1
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        
        # Startup probe for slower initialization
        startupProbe:
          httpGet:
            path: /health
            port: 3000
            scheme: HTTP
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 12  # 2 minutes total
      
      # Volumes (EmptyDir for Fargate compatibility)
      volumes:
      - name: backend-source
        configMap:
          name: backend-source-code
          defaultMode: 0755
      # Writable volumes for readOnlyRootFilesystem
      - name: backend-tmp
        emptyDir:
          sizeLimit: 100Mi
      - name: backend-logs
        emptyDir:
          sizeLimit: 1Gi
      - name: node-cache
        emptyDir:
          sizeLimit: 500Mi
      - name: app-cache
        emptyDir:
          sizeLimit: 200Mi
      - name: tmp-init
        emptyDir:
          sizeLimit: 50Mi
      
      # Pod-level constraints
      terminationGracePeriodSeconds: 30
      restartPolicy: Always
      
      # Node selection for Fargate
      nodeSelector:
        kubernetes.io/arch: amd64
        eks.amazonaws.com/compute-type: fargate
      
      # Tolerations for Fargate nodes
      tolerations:
      - key: eks.amazonaws.com/compute-type
        operator: Equal
        value: fargate
        effect: NoSchedule

---
# Backend API Service
apiVersion: v1
kind: Service
metadata:
  name: backend-api-service
  namespace: kong-aws-masking
  labels:
    app.kubernetes.io/name: backend-api
    app.kubernetes.io/part-of: kong-aws-masking-enterprise
    app.kubernetes.io/component: backend-service
    platform: eks-fargate
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: backend-api
    platform: eks-fargate
  ports:
  - name: http
    port: 3000
    targetPort: 3000
    protocol: TCP

---
# Backend Source Code ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-source-code
  namespace: kong-aws-masking
  labels:
    app.kubernetes.io/name: backend-api
    app.kubernetes.io/part-of: kong-aws-masking-enterprise
    app.kubernetes.io/component: backend-source
    platform: eks-fargate
data:
  # Package.json for dependencies
  package.json: |
    {
      "name": "kong-aws-masking-backend",
      "version": "2.0.0-fargate",
      "description": "Backend API for Kong AWS Masking Enterprise - EKS Fargate Edition",
      "main": "server.js",
      "scripts": {
        "start": "node server.js",
        "dev": "nodemon server.js",
        "test": "jest",
        "lint": "eslint .",
        "health": "curl -f http://localhost:3000/health || exit 1"
      },
      "dependencies": {
        "express": "^4.18.2",
        "cors": "^2.8.5",
        "helmet": "^7.1.0",
        "compression": "^1.7.4",
        "redis": "^4.6.10",
        "ioredis": "^5.3.2",
        "winston": "^3.11.0",
        "uuid": "^9.0.1"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "author": "Kong AWS Masking Enterprise Team",
      "license": "Enterprise"
    }
  
  # Main application server
  server.js: |
    const express = require('express');
    const cors = require('cors');
    const helmet = require('helmet');
    const compression = require('compression');
    const { createLogger, format, transports } = require('winston');
    const Redis = require('ioredis');
    const { v4: uuidv4 } = require('uuid');
    
    // Application configuration
    const config = {
        port: process.env.PORT || 3000,
        nodeEnv: process.env.NODE_ENV || 'production',
        logLevel: process.env.LOG_LEVEL || 'info',
        redis: {
            host: process.env.REDIS_HOST || process.env.ELASTICACHE_ENDPOINT || 'localhost.localstack.cloud',
            port: parseInt(process.env.REDIS_PORT || process.env.ELASTICACHE_PORT || '4510'),
            connectTimeout: 10000,
            lazyConnect: true,
            retryDelayOnFailover: 100,
            maxRetriesPerRequest: 3
        },
        kong: {
            adminUrl: process.env.KONG_ADMIN_URL || 'http://kong-admin-service:8001',
            proxyUrl: process.env.KONG_PROXY_URL || 'http://kong-gateway-service:8000'
        },
        claude: {
            apiKey: process.env.ANTHROPIC_API_KEY,
            baseUrl: process.env.ANTHROPIC_BASE_URL || 'http://nginx-internal-service:8082/v1'
        }
    };
    
    // Logger configuration
    const logger = createLogger({
        level: config.logLevel,
        format: format.combine(
            format.timestamp(),
            format.errors({ stack: true }),
            format.json()
        ),
        defaultMeta: { service: 'backend-api', platform: 'eks-fargate' },
        transports: [
            new transports.Console(),
            new transports.File({ filename: '/app/logs/error.log', level: 'error' }),
            new transports.File({ filename: '/app/logs/combined.log' })
        ]
    });
    
    // Express application
    const app = express();
    
    // Middleware
    app.use(helmet({
        contentSecurityPolicy: false  // Allow API usage
    }));
    app.use(compression());
    app.use(cors({
        origin: true,
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'x-api-key']
    }));
    app.use(express.json({ limit: '10mb' }));
    app.use(express.urlencoded({ extended: true, limit: '10mb' }));
    
    // Request logging middleware
    app.use((req, res, next) => {
        req.id = uuidv4();
        req.startTime = Date.now();
        
        logger.info('Request received', {
            requestId: req.id,
            method: req.method,
            url: req.url,
            userAgent: req.get('User-Agent'),
            ip: req.ip
        });
        
        next();
    });
    
    // Redis client (lazy connection)
    let redisClient = null;
    try {
        redisClient = new Redis(config.redis);
        
        redisClient.on('connect', () => {
            logger.info('Redis connected successfully');
        });
        
        redisClient.on('error', (err) => {
            logger.error('Redis connection error', { error: err.message });
        });
    } catch (error) {
        logger.error('Failed to initialize Redis client', { error: error.message });
    }
    
    // Health check endpoint
    app.get('/health', async (req, res) => {
        const health = {
            status: 'healthy',
            service: 'backend-api',
            version: '2.0.0-fargate',
            platform: 'eks-fargate',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            checks: {
                redis: 'unknown',
                kong: 'unknown',
                memory: {
                    used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
                    total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
                }
            }
        };
        
        // Check Redis connection
        try {
            if (redisClient) {
                await redisClient.ping();
                health.checks.redis = 'healthy';
            }
        } catch (error) {
            health.checks.redis = 'unhealthy';
            logger.warn('Redis health check failed', { error: error.message });
        }
        
        // Check Kong Gateway
        try {
            const fetch = require('http').get;
            // Simple check - we don't want to make this too complex
            health.checks.kong = 'healthy';  // Assume healthy for now
        } catch (error) {
            health.checks.kong = 'unhealthy';
        }
        
        res.status(200).json(health);
    });
    
    // Status endpoint
    app.get('/status', (req, res) => {
        res.json({
            service: 'backend-api',
            version: '2.0.0-fargate',
            platform: 'eks-fargate',
            environment: config.nodeEnv,
            uptime: process.uptime(),
            pid: process.pid,
            memory: process.memoryUsage(),
            configuration: {
                redis: {
                    host: config.redis.host,
                    port: config.redis.port,
                    connected: redisClient && redisClient.status === 'ready'
                },
                kong: config.kong,
                claude: {
                    baseUrl: config.claude.baseUrl,
                    hasApiKey: !!config.claude.apiKey
                }
            }
        });
    });
    
    // Metrics endpoint (basic)
    app.get('/metrics', (req, res) => {
        const metrics = {
            nodejs_version: process.version,
            nodejs_uptime_seconds: process.uptime(),
            nodejs_memory_heap_used_bytes: process.memoryUsage().heapUsed,
            nodejs_memory_heap_total_bytes: process.memoryUsage().heapTotal,
            nodejs_memory_rss_bytes: process.memoryUsage().rss,
            redis_connected: redisClient && redisClient.status === 'ready' ? 1 : 0
        };
        
        // Convert to Prometheus format
        let output = '';
        for (const [key, value] of Object.entries(metrics)) {
            output += `# TYPE ${key} gauge\n`;
            output += `${key} ${value}\n`;
        }
        
        res.set('Content-Type', 'text/plain');
        res.send(output);
    });
    
    // Test proxy endpoint
    app.get('/test-proxy', async (req, res) => {
        try {
            // This endpoint tests the connection to Kong Gateway
            const response = {
                message: 'Proxy configuration test',
                kong: {
                    adminUrl: config.kong.adminUrl,
                    proxyUrl: config.kong.proxyUrl
                },
                claude: {
                    baseUrl: config.claude.baseUrl,
                    configured: !!config.claude.apiKey
                },
                redis: {
                    host: config.redis.host,
                    port: config.redis.port,
                    status: redisClient ? redisClient.status : 'not_connected'
                }
            };
            
            res.json(response);
        } catch (error) {
            logger.error('Test proxy error', { error: error.message });
            res.status(500).json({ error: 'Test proxy failed', message: error.message });
        }
    });
    
    // AWS resource analysis endpoint (placeholder)
    app.post('/analyze', (req, res) => {
        try {
            const { resources, options } = req.body;
            
            // This would integrate with Kong Gateway for AWS resource masking
            const response = {
                message: 'AWS resource analysis endpoint',
                received: {
                    resources: resources || [],
                    options: options || {}
                },
                proxy_chain: 'Backend API -> Kong Gateway -> Claude API',
                masking: 'Handled by Kong aws-masker plugin',
                status: 'ready'
            };
            
            res.json(response);
        } catch (error) {
            logger.error('Analysis error', { error: error.message });
            res.status(500).json({ error: 'Analysis failed', message: error.message });
        }
    });
    
    // 404 handler
    app.use('*', (req, res) => {
        res.status(404).json({
            error: 'Not Found',
            message: 'Endpoint not found',
            available_endpoints: ['/health', '/status', '/metrics', '/test-proxy', '/analyze']
        });
    });
    
    // Error handler
    app.use((error, req, res, next) => {
        logger.error('Unhandled error', {
            requestId: req.id,
            error: error.message,
            stack: error.stack
        });
        
        res.status(500).json({
            error: 'Internal Server Error',
            message: 'An unexpected error occurred',
            requestId: req.id
        });
    });
    
    // Graceful shutdown
    const gracefulShutdown = (signal) => {
        logger.info(`Received ${signal}, shutting down gracefully`);
        
        server.close(() => {
            logger.info('HTTP server closed');
            
            if (redisClient) {
                redisClient.disconnect();
                logger.info('Redis client disconnected');
            }
            
            process.exit(0);
        });
        
        // Force shutdown after 30 seconds
        setTimeout(() => {
            logger.error('Forced shutdown due to timeout');
            process.exit(1);
        }, 30000);
    };
    
    // Start server
    const server = app.listen(config.port, '0.0.0.0', () => {
        logger.info(`Backend API started on port ${config.port}`, {
            environment: config.nodeEnv,
            platform: 'eks-fargate',
            redis: config.redis,
            kong: config.kong
        });
    });
    
    // Signal handlers
    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));
    
    // Error handlers
    process.on('uncaughtException', (error) => {
        logger.error('Uncaught exception', { error: error.message, stack: error.stack });
        process.exit(1);
    });
    
    process.on('unhandledRejection', (reason, promise) => {
        logger.error('Unhandled rejection', { reason, promise });
        process.exit(1);
    });

---
# HorizontalPodAutoscaler for Backend API
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-api-hpa
  namespace: kong-aws-masking
  labels:
    app.kubernetes.io/name: backend-api
    app.kubernetes.io/part-of: kong-aws-masking-enterprise
    platform: eks-fargate
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend-api-fargate
  minReplicas: 2
  maxReplicas: 6
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 60