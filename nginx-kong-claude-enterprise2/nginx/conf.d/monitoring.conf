# Monitoring and observability configuration

# Log format for structured monitoring
map $status $loggable {
    ~^[23]  0;  # Don't log 2xx and 3xx by default
    default 1;
}

# Request ID generation if not provided
map $http_x_request_id $request_id {
    default $http_x_request_id;
    ""      $request_time-$msec-$remote_addr-$connection;
}

# Monitoring endpoints server block
server {
    listen 9090;
    server_name _;
    
    access_log off;
    
    # Prometheus metrics endpoint (basic)
    location /metrics {
        default_type text/plain;
        
        # Basic metrics using nginx variables
        return 200 '# HELP nginx_http_requests_total Total number of HTTP requests
# TYPE nginx_http_requests_total counter
nginx_http_requests_total{status="2xx"} $body_bytes_sent
nginx_http_requests_total{status="4xx"} $body_bytes_sent
nginx_http_requests_total{status="5xx"} $body_bytes_sent

# HELP nginx_http_request_duration_seconds HTTP request latency
# TYPE nginx_http_request_duration_seconds histogram
nginx_http_request_duration_seconds_bucket{le="0.1"} $request_time
nginx_http_request_duration_seconds_bucket{le="0.5"} $request_time
nginx_http_request_duration_seconds_bucket{le="1.0"} $request_time
nginx_http_request_duration_seconds_bucket{le="5.0"} $request_time
nginx_http_request_duration_seconds_bucket{le="+Inf"} $request_time

# HELP nginx_up Whether the nginx is up
# TYPE nginx_up gauge
nginx_up 1

# HELP nginx_connections_current Current number of client connections
# TYPE nginx_connections_current gauge
nginx_connections_current{state="active"} $connections_active
nginx_connections_current{state="reading"} $connections_reading
nginx_connections_current{state="writing"} $connections_writing
nginx_connections_current{state="waiting"} $connections_waiting
';
    }
    
    # Extended health check with dependencies
    location /health/full {
        default_type application/json;
        
        # Check Kong backend health
        set $kong_status "unknown";
        set $kong_response_time "0";
        
        content_by_lua_block {
            local cjson = require "cjson.safe"
            local http = require "resty.http"
            
            local httpc = http.new()
            httpc:set_timeout(3000)
            
            local start_time = ngx.now()
            local res, err = httpc:request_uri("http://kong:8001/status", {
                method = "GET",
                headers = {
                    ["Content-Type"] = "application/json",
                }
            })
            local end_time = ngx.now()
            
            local kong_status = "unhealthy"
            local kong_response_time = (end_time - start_time) * 1000
            
            if res and res.status == 200 then
                kong_status = "healthy"
            end
            
            local health_data = {
                status = "healthy",
                service = "nginx-proxy",
                timestamp = ngx.utctime(),
                version = ngx.var.nginx_version,
                dependencies = {
                    kong = {
                        status = kong_status,
                        response_time_ms = kong_response_time
                    }
                },
                metrics = {
                    connections = {
                        active = ngx.var.connections_active,
                        reading = ngx.var.connections_reading,
                        writing = ngx.var.connections_writing,
                        waiting = ngx.var.connections_waiting
                    }
                }
            }
            
            ngx.status = 200
            ngx.header["Content-Type"] = "application/json"
            ngx.say(cjson.encode(health_data))
        }
    }
    
    # Detailed nginx status
    location /status {
        stub_status on;
    }
}